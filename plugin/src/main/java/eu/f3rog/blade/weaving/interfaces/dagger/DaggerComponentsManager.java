package eu.f3rog.blade.weaving.interfaces.dagger;

import java.util.ArrayList;
import java.util.List;

import eu.f3rog.javassist.JavassistHelper;
import eu.f3rog.javassist.exception.AfterBurnerImpossibleException;
import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.NotFoundException;

import static eu.f3rog.blade.weaving.util.WeavingUtil.hasAnnotation;

final class DaggerComponentsManager {

    private static final String DAGGER_COMPONENT_PREFIX = "Dagger";
    private static final String DAGGER_COMPONENT_CLASS_NAME = "dagger.Component";
    private static final String DAGGER_SUBCOMPONENT_CLASS_NAME = "dagger.Subcomponent";

    private final ClassPool mClassPool;
    private final List<CtClass> mAllClasses;
    private List<CtClass> mComponentImplementationClasses;

    public DaggerComponentsManager(ClassPool classPool, List<CtClass> classes) {
        mClassPool = classPool;
        mAllClasses = classes;
    }

    private List<CtClass> getComponentImplementationClasses() {
        if (mComponentImplementationClasses == null) {
            mComponentImplementationClasses = new ArrayList<>();
            // System.out.printf(" loading component classes\n");

            for (final CtClass cls : mAllClasses) {
                // every component implementation class generated by dagger starts with the same prefix
                if (cls.getSimpleName().startsWith(DAGGER_COMPONENT_PREFIX)) {
                    // System.out.printf(" checking component class: %s\n", cls.getName());

                    // check the definition class made by developer (same name without prefix)
                    final String definitionClassName = cls.getPackageName() + "." + cls.getSimpleName().substring(DAGGER_COMPONENT_PREFIX.length());
                    final CtClass definitionClass;
                    try {
                        // System.out.printf(" checking definition class: %s\n", definitionClassName);
                        definitionClass = mClassPool.get(definitionClassName);

                    } catch (NotFoundException e) {
                        continue;
                    }
                    // definition class has to be annotated by @Component or @Subcompoenent
                    if (hasAnnotation(definitionClass, DAGGER_COMPONENT_CLASS_NAME, DAGGER_SUBCOMPONENT_CLASS_NAME)) {
                        // System.out.printf(" found component implementation class: %s\n", cls.getName());
                        mComponentImplementationClasses.add(cls);
                    }

                }
            }
        }
        return mComponentImplementationClasses;
    }

    public void weaveFor(final CtClass injectedClass, List<String> presenterFieldNames, String wrapMethod, final JavassistHelper javassistHelper) {
        for (final CtClass componentClass : getComponentImplementationClasses()) {
            final CtMethod[] methods = componentClass.getDeclaredMethods();
            for (final CtMethod method : methods) {
                // find the inject method
                // the return type and also parameter type must be the injected class
                // (we can't be sure of the name)
                try {
                    final CtClass[] parameterTypes = method.getParameterTypes();
                    final CtClass returnType = method.getReturnType();
                    if (parameterTypes.length != 1 || !parameterTypes[0].equals(injectedClass) || !returnType.equals(injectedClass)) {
                        // wrong method
                        continue;
                    }
                } catch (NotFoundException e) {
                    continue;
                }

                // method found
                System.out.printf(" found method: %s\n", method.getName());
                final ComponentMethodEditor editor = new ComponentMethodEditor(presenterFieldNames, wrapMethod);
                try {
                    javassistHelper.editMethod(editor, componentClass, method.getName(), injectedClass);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }
}