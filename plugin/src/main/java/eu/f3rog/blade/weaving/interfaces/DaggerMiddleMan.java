package eu.f3rog.blade.weaving.interfaces;

import java.util.ArrayList;
import java.util.List;

import eu.f3rog.javassist.JavassistHelper;
import eu.f3rog.javassist.MethodEditor;
import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.NotFoundException;
import javassist.expr.FieldAccess;
import javassist.expr.MethodCall;

/**
 * Changes classes generated by Dagger2 using bytecode weaving
 *
 * @author FrantisekGazo
 */
final class DaggerMiddleMan {

    void weaveFor(final CtClass injectedClass, List<String> presenterFieldNames, String wrapMethod, final JavassistHelper javassistHelper) {
        final ClassPool classPool = injectedClass.getClassPool();

        CtClass injectorClass;
        try {
            injectorClass = classPool.get(injectedClass.getName() + "_MembersInjector");
        } catch (NotFoundException e) {
            return;
        }

        try {
            //System.out.printf(" ~> %s\n", injectorClass.getName());

            DaggerMethodEditor editor = new DaggerMethodEditor(presenterFieldNames, wrapMethod);
            javassistHelper.editMethod(editor, injectorClass, "injectMembers", injectedClass);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static final class DaggerMethodEditor
            extends MethodEditor {

        private final List<String> mPresenterFieldNames;
        private final String mWrapMethod;
        private final List<String> mFieldAccessList;
        private int mCurrentFieldAccess;
        private boolean mFindFields;

        DaggerMethodEditor(List<String> presenterFieldNames, String wrapMethod) {
            mPresenterFieldNames = presenterFieldNames;
            mWrapMethod = wrapMethod;
            mFieldAccessList = new ArrayList<>();
            mCurrentFieldAccess = 0;
            mFindFields = false;
        }

        @Override
        public void edit(FieldAccess f) throws CannotCompileException {
            super.edit(f);

            if (mFindFields) {
                String fieldName = f.getFieldName();
                //System.out.printf("field access '%s' ...\n", fieldName);

                mFieldAccessList.add(fieldName);
            } else {
                mCurrentFieldAccess += 1;
            }
        }

        @Override
        public void edit(MethodCall m) throws CannotCompileException {
            super.edit(m);

            if (mFindFields) {
                return;
            }

            if (!m.getMethodName().equals("get")) {
                return;
            }

            String providerField = mFieldAccessList.get(mCurrentFieldAccess - 1);
            String instanceField = mFieldAccessList.get(mCurrentFieldAccess);

            if (!mPresenterFieldNames.contains(instanceField)) {
                return;
            }

            //System.out.printf("replacing %s ", m.getMethodName());

            String statement = String.format("{ $_ = %s(%s, \"%s\", %s); }",
                    mWrapMethod, "instance", instanceField, providerField);

            //System.out.printf("with %s\n", statement);

            m.replace(statement);
        }

        @Override
        public void instrument(CtMethod method) throws CannotCompileException {
            mFieldAccessList.clear();
            mCurrentFieldAccess = 0;

            // go through the method and find all field accesses
            mFindFields = true;
            method.instrument(this);

            // got through the method and modify it
            mFindFields = false;
            method.instrument(this);
        }
    }
}
